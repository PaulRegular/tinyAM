% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dat.R
\name{make_dat}
\alias{make_dat}
\title{Build a self-contained data list for TAM}
\usage{
make_dat(
  obs,
  years = NULL,
  ages = NULL,
  N_settings = list(process = "iid", init_N0 = FALSE),
  F_settings = list(process = "approx_rw", mu_form = NULL),
  M_settings = list(process = "off", mu_form = NULL, mu_supplied = ~I(0.2), age_breaks =
    NULL, first_dev_year = NULL),
  catch_settings = list(sd_form = ~1, sd_supplied = NULL, fill_missing = TRUE),
  index_settings = list(sd_form = ~1, sd_supplied = NULL, q_form = ~q_block,
    fill_missing = TRUE),
  proj_settings = NULL
)
}
\arguments{
\item{obs}{A list of tidy observation data.frames: \code{catch}, \code{index},
\code{weight}, and \code{maturity}. See \strong{Details}.}

\item{years}{Integer vector of model years (strictly increasing).
Inferred from observed data (non-projection) if \code{NULL}.}

\item{ages}{Integer vector of model ages (strictly increasing).
Inferred from observed data (non-projection) if \code{NULL}. If the ages in
the data extend beyond \code{max(ages)}, the \code{"obs"} column is summed for \code{catch}
and \code{index} data, and averaged for \code{weight} and \code{maturity} data.}

\item{N_settings}{A list with elements:
\itemize{
\item \code{process}: one of \code{"off"}, \code{"iid"}, \code{"approx_rw"}, or \code{"ar1"}.
\item \code{init_N0}: logical; if \code{TRUE}, estimate an initial level for the
first-year abundance. If \code{process == "off"} and \code{init_N0 == FALSE},
this is forced to \code{TRUE}.
}}

\item{F_settings}{A list with elements:
\itemize{
\item \code{process}: one of \code{"iid"}, \code{"approx_rw"}, or \code{"ar1"}.
\item \code{mu_form}: an optional formula for mean-\eqn{F}.
\item \code{mean_ages}: optional vector of ages to include in population weighted
average F (\code{F_bar}) calculations. All ages used if absent.
}}

\item{M_settings}{A list with elements:
\itemize{
\item \code{process}: one of \code{"off"}, \code{"iid"}, \code{"approx_rw"}, or \code{"ar1"}.
\item \code{mu_form}: optional formula for mean-\eqn{M} (on the log scale) built
on \code{obs$weight}. If provided together with \code{mu_supplied}, the intercept
in \code{mu_form} is dropped (warning) so supplied levels act as fixed offsets.
\item \code{mu_supplied}: optional one-sided formula giving supplied (non-estimated)
log-\eqn{M} offsets, e.g. \code{~ I(0.2)} or a column reference such as
\code{~ log(M_assumption)} stored in the \code{obs$weight} data.frame.
\item \code{age_breaks}: optional integer break points used by \code{\link[=cut_ages]{cut_ages()}} to
define \code{age_blocks} for coupling \eqn{M} deviations across ages.
When a narrower set of \code{age_breaks} than modeled \code{ages} is provided,
deviations are only estimated for ages within the specified range; ages
outside this range are fixed to their mean or assumed levels. By default,
deviations are estimated for all modeled ages except the youngest, reducing
confounding between \eqn{M} and recruitment.
\item \code{first_dev_year}: integer year at which to start estimating \eqn{M} deviations.
Defaults to the second modeled year if \code{NULL}. Anchoring the first year
to mean or supplied levels helps minimize confounding between early \eqn{M}
estimates, initial abundance, and catchability, leading to more stable estimation.
\item \code{mean_ages}: optional vector of ages to include in population weighted
average M (\code{M_bar}) calculations. All ages used if absent.
}}

\item{catch_settings}{A list with elements:
\itemize{
\item \code{sd_form}: formula for observation SD blocks for catch-at-age data.
\item \code{sd_supplied}: optional one-sided formula giving supplied SDs (on the natural
scale of the log-observation residuals) for catch-at-age data. When provided,
the intercept is removed from \code{sd_form} so supplied SDs act as offsets.
\item \code{fill_missing}: logical – fill missing values, and zeros, using random effects?
Defaults to \code{TRUE}. Note that one-step-ahead residuals are not currently working when \code{TRUE}.
}}

\item{index_settings}{A list with elements:
\itemize{
\item \code{sd_form}: formula for observation SD blocks for index-at-age data.
\item \code{sd_supplied}: optional one-sided formula giving supplied SDs (on the natural
scale of the log-observation residuals) for index-at-age data. When provided,
the intercept is removed from \code{sd_form} so supplied SDs act as offsets.
\item \code{q_form}: formula for catchability blocks, evaluated on the index table (e.g. \code{~ q_block}).
\item \code{fill_missing}: logical – fill missing values, and zeros, using random effects?
Defaults to \code{TRUE}. Note that one-step-ahead residuals are not currently working when \code{TRUE}.
}}

\item{proj_settings}{Optional list with elements:
\itemize{
\item \code{n_proj}: number of years to project (default \code{NULL} disables projections).
\item \code{n_mean}: number of terminal years to average when adding projection rows. Only the \code{"obs"} columns
are averaged. All other columns are copied from the terminal year (by \code{age}).
\item \code{F_mult}: multiplier to apply to terminal F to set a level to carry forward in the projection years
(default = \code{1} to assume status quo F through the projection years). Can be a value of length 1 or
length = \code{n_proj}. When it is a vector of length one, that multiplier is recycled across all
projection years.
}}
}
\value{
A named list \code{dat} containing:
\itemize{
\item \code{years}, \code{ages} — modeled ranges (years includes \code{proj_years}, if used)
\item \code{is_proj} — logical vector identifying whether year is projected
\item \code{proj_years} — integer vector of projection years, if used
\item \code{obs} — per-type tables restricted to \code{years} x \code{ages} (including \code{proj_years}, if used)
\item \code{W}, \code{P} — mean weight-at-age, and proportion mature at age matrices (\verb{year x age})
\item \code{obs_map} — stack of \code{obs$catch} and \code{obs$index} mapping variables
\item \code{log_obs}, \code{is_missing}, \code{is_observed}, \code{observed} - vector of log observations (with NA),
logical vector indicating missing and observed values, and vector of non-missing values, respectively.
\item design matrices: \code{sd_catch_modmat}, \code{sd_index_modmat}, \code{q_modmat}, and optionally \code{F_modmat}, \code{M_modmat}
\item mean-level placeholders: \code{log_mu_f} and/or \code{log_mu_m} (or \code{log_mu_supplied_m})
\item process settings: \code{N_settings}, \code{F_settings}, \code{M_settings}, \code{catch_settings}, \code{index_settings}
\item projection settings: \code{proj_settings}
\item AR(1) parameter assumptions, \verb{logit_phi_*}, if applicable
}
}
\description{
\code{make_dat()} converts tidy observation inputs and modeling options into the
structured list \code{dat} expected by TAM’s likelihood and simulation functions.
It expands an age–year grid, merges observations, constructs design matrices for
observation SDs, catchability, and mean-\eqn{F} and/or mean-\eqn{M} (when used),
and derives helper mappings and settings.
}
\details{
\strong{Observation handling}
\itemize{
\item Inputs are expected as a list with components \code{catch}, \code{index}, \code{weight},
and \code{maturity}. Each must include columns \code{year}, \code{age}, and a value column
named \code{obs} (for \code{catch}/\code{index}) or renamed from \code{weight}/\code{mat}. See
\link{cod_obs} for an example of the required structure.
\item Observations are merged to the full \code{expand.grid(year, age)}.
\item A combined observation table is created for catch and index; \code{log(0)} is
treated as \code{NA} (to be handled via random effects).
}

\strong{Design matrices}
\itemize{
\item \code{catch_settings$sd_form} is evaluated on the catch table to produce
\code{sd_catch_modmat}.
\item \code{index_settings$sd_form} is evaluated on the index table to produce
\code{sd_index_modmat}.
\item \code{index_settings$q_form} is evaluated on the index table to produce
\code{q_modmat}.
\item If \code{M_settings$mu_form} is provided, \code{M_modmat <- model.matrix(mu_form, data = obs$weight)}. If \code{mu_supplied} is also provided, the intercept
in \code{mu_form} is dropped and a warning is issued.
\item If neither \code{M_settings$mu_form} nor \code{M_settings$mu_supplied} is supplied,
the function stops, because \eqn{M} must be identified by either a supplied
surface or a mean structure.
}

\strong{Process options and guards}
\itemize{
\item If \code{N_settings$process == "off"} and \code{init_N0 == FALSE}, \code{init_N0} is
forced to \code{TRUE} (with a warning) so the first-year abundance is
estimable.
\item \code{M_settings$age_breaks} (vector of break points on ages)
defines \code{M_settings$age_blocks} via \code{\link[=cut_ages]{cut_ages()}}, used
to couple \eqn{M} deviations across age.
\item The AR(1) correlation parameters are only initialized for
processes whose \code{process == "ar1"}. Correlations are assumed to be 0
when \code{process == "iid"}, and 0.99 when \code{process == "approx_rw"} to approximate
a random walk across ages and years.
}

\strong{Projections (optional)}
\itemize{
\item If \code{proj_settings} is supplied, the function adds:
\itemize{
\item \code{proj_years}: the set of projection years;
\item \code{is_proj}: logical vector identifying the projection years;
\item \code{obs$...$is_proj} rows to each \code{obs} table identifying the projection years.
}
}
}
\examples{
dat <- make_dat(
  cod_obs,
  years = 1983:2024,
  ages = 2:14,
  N_settings = list(process = "iid", init_N0 = FALSE),
  F_settings = list(process = "approx_rw", mu_form = NULL),
  M_settings = list(process = "off", mu_supplied = ~ I(0.3)),
  catch_settings = list(sd_form = ~ 1),
  index_settings = list(sd_form = ~ 1, q_form = ~ q_block)
)
names(dat)

## With projection settings
dat <- make_dat(
  cod_obs,
  N_settings = list(process = "iid", init_N0 = FALSE),
  F_settings = list(process = "approx_rw", mu_form = NULL),
  M_settings = list(process = "off", mu_supplied = ~ I(0.3)),
  catch_settings = list(sd_form = ~ 1),
  index_settings = list(sd_form = ~ 1, q_form = ~ q_block),
  proj_settings = list(n_proj = 3, n_mean = 3, F_mult = 1)
)

}
\seealso{
\code{\link[stats:model.matrix]{stats::model.matrix()}}, \code{\link[=cut_ages]{cut_ages()}}
}
