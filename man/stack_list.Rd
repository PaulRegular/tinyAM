% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tidy.R
\name{stack_list}
\alias{stack_list}
\title{Stack a list of tables with an identifier column}
\usage{
stack_list(
  x,
  label = "model",
  label_type = c("auto", "numeric", "character", "factor")
)
}
\arguments{
\item{x}{A list of data frames (or objects coercible to data frames).}

\item{label}{A character scalar giving the identifier column name to add. Set
to \code{NULL} to omit the identifier column. Default is \code{"model"}.}

\item{label_type}{Desired type for the identifier column: automatic
conversion via \code{\link[utils:type.convert]{utils::type.convert()}} (\code{"auto"}, the default), or
explicit coercion to \code{"numeric"}, \code{"character"}, or \code{"factor"}.}
}
\value{
A single data frame produced by row-binding the list elements. If
\code{label} is not \code{NULL}, the identifier column is the first column in the
output.
}
\description{
Convenience wrapper around \code{\link[base:cbind]{base::rbind()}} for stacking a (named) list of
data frames while recording the source list element in a label column. When
the list is named, the names are used as labels; otherwise, integer indices
(\code{"1"}, \code{"2"}, â€¦) are used. Columns absent in some elements are filled with
\code{NA} so inputs need only share column \emph{names} in common.
}
\examples{
lst <- list(
  retro_1 = data.frame(age = 2:4, rho = runif(3)),
  retro_2 = data.frame(age = 2:4, rho = runif(3))
)
stack_list(lst, label = "retro")

}
